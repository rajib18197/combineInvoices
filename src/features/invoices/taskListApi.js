import { supabase } from "../../services/supabase";
import apiSlice from "../serverState/apiSlice";
import { invoicesApi } from "./invoicesApi";

const taskListApi = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getAllTaskList: builder.query({
      queryFn: async () => {
        const { data: taskList, error } = await supabase
          .from("taskList")
          .select("*");

        if (error) return { error };
        return { data: taskList };
      },
    }),

    getAllTaskByInvoiceId: builder.query({
      queryFn: async (id) => {
        const { data: taskMenu, error } = await supabase
          .from("taskList")
          .select("*")
          .eq("invoiceId", id);

        if (error) return { error };
        return { data: taskMenu };
      },
    }),

    getAllTaskMenu: builder.query({
      queryFn: async (id) => {
        const { data: taskMenu, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("projectId", id);

        if (error) return { error };
        return { data: taskMenu };
      },
    }),

    addTaskList: builder.mutation({
      queryFn: async ({ newTask, updateInvoice }) => {
        const { data, error } = await supabase
          .from("taskList")
          .insert([newTask])
          .select()
          .single();

        if (error) return { error };
        return { data };
      },

      onQueryStarted: async (arg, { dispatch, queryFulfilled }) => {
        console.log(1);
        // If we doing optimistic update here then It is going to be problem in delete or update because we can't passed the id of the newly created task as this will be generated by the API itself. since we can not get the id here that's why it is best to use pessimistic update.
        const response = await queryFulfilled;
        dispatch(
          apiSlice.util.updateQueryData(
            "getAllTaskByInvoiceId",
            arg.newTask.invoiceId,
            (draft) => {
              console.log(draft);
              draft.push(response.data);
            }
          )
        );
        console.log(response.data);
        const r = await dispatch(
          apiSlice.endpoints.updateInvoice.initiate({
            id: arg.newTask.invoiceId,
            obj: {
              quantity: arg.updateInvoice.quantity,
              totalPrice: arg.updateInvoice.totalPrice,
            },
          })
        ).unwrap();
        console.log(r);
      },
    }),

    updateTask: builder.mutation({
      queryFn: async ({ id, obj, invoiceId, invoiceObj }) => {
        console.log(obj);
        const { data, error } = await supabase
          .from("taskList")
          .update([obj])
          .eq("id", id)
          .select();

        if (error) return { error };
        console.log(data);
        return { data };
      },

      onQueryStarted: async (arg, { dispatch, queryFulfilled }) => {
        const patchResult = dispatch(
          apiSlice.util.updateQueryData(
            "getAllTaskByInvoiceId",
            arg.invoiceId,
            (draft) => {
              // console.log(draft.data);
              const taskToUpdate = draft.find((c) => {
                console.log(c.id, arg.id);
                return Number(c.id) === Number(arg.id);
              });
              // console.log(taskToUpdate);
              taskToUpdate.quantity = arg.obj.quantity;
            }
          )
        );

        try {
          await queryFulfilled;

          await dispatch(
            apiSlice.endpoints.updateInvoice.initiate({
              id: arg.invoiceId,
              obj: {
                quantity: arg.invoiceObj.quantity,
                totalPrice: arg.invoiceObj.totalPrice,
              },
            })
          ).unwrap();
        } catch {
          patchResult.undo();
        }
      },
    }),

    deleteTask: builder.mutation({
      queryFn: async ({ id, invoice }) => {
        console.log(id);
        const { error } = await supabase.from("taskList").delete().eq("id", id);

        if (error) return { error };
        return { data: `TaskList Id - ${id} has been deleted` };
      },

      onQueryStarted: async (arg, { dispatch, queryFulfilled }) => {
        console.log(arg);
        const patchResult = dispatch(
          apiSlice.util.updateQueryData(
            "getAllTaskByInvoiceId",
            arg.invoice.invoiceId,
            (draft) => {
              const taskToDeleteIndex = draft.findIndex(
                (c) => Number(c.id) === Number(arg.id)
              );
              console.log(taskToDeleteIndex, arg.invoice);
              draft.splice(taskToDeleteIndex, 1);
            }
          )
        );

        try {
          await queryFulfilled;

          const t = await dispatch(
            apiSlice.endpoints.updateInvoice.initiate({
              id: arg.invoice.invoiceId,
              obj: {
                quantity: arg.invoice.quantity,
                totalPrice: arg.invoice.totalPrice,
              },
            })
          ).unwrap();

          console.log(t);
        } catch {
          patchResult.undo();
        }
      },
    }),
  }),
});

export const {
  useGetAllTaskListQuery,
  useGetAllTaskMenuQuery,
  useAddTaskListMutation,
  useGetAllTaskByInvoiceIdQuery,
  useUpdateTaskMutation,
  useDeleteTaskMutation,
} = taskListApi;
